"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const gunzipSync = require('zlib').gunzipSync;
// We limit the logged body due to CloudWatch 256Kb per line limitation,
// CloudWatch costs and, last but not least, websocket exploding on
// larger sizes.
// Tests have shown that 8Kb length results in responsive UI with enough
// captured information.
const MAX_BODY_LENGTH = 8 * 1024;
function base64encode(str) {
    return Buffer.from(str).toString('base64');
}
// Gets the content encoding value from the given headers, no matter
// what case the header has been passed through.
function getContentEncoding(headers) {
    if (!headers) {
        return undefined;
    }
    const CONTENT_ENCODING = 'content-encoding';
    let encoding = headers[CONTENT_ENCODING];
    if (!encoding) {
        for (let name of Object.keys(headers)) {
            if (name.toLowerCase() === CONTENT_ENCODING) {
                encoding = headers[name];
                break;
            }
        }
    }
    if (Array.isArray(encoding)) {
        if (encoding.length) {
            encoding = encoding[0];
        }
        else {
            encoding = undefined;
        }
    }
    return encoding;
}
// For the purposes of HTTP request and response logging we log the body.
// This function returns an object with possibly truncated body, full body
// length and a flag set to true if the body was truncated.
// The object is directly included in the HTTP request logging result.
// This functionn never throws as it is just related to logging and we don't
// want a request to ever fail due to logging issues.
function getBodyLoggingData(rawBody, headers) {
    try {
        if (!rawBody || rawBody.length === 0) {
            return {};
        }
        let body;
        if (typeof rawBody === 'string') {
            body = Buffer.from(rawBody, 'base64');
        }
        else if (Buffer.isBuffer(rawBody)) {
            body = rawBody;
        }
        else if (Array.isArray(rawBody)) {
            body = Buffer.concat(rawBody);
        }
        else {
            // We don't know what we have so the best we can do is return a user visible error.
            return {
                body: base64encode(`Unknown body format: ${typeof rawBody}`),
                // @ts-ignore
                bodyLength: rawBody.length,
                bodyTruncated: true,
            };
        }
        const encoding = getContentEncoding(headers);
        if (typeof encoding === 'string' && encoding.toLowerCase() === 'gzip') {
            try {
                body = gunzipSync(body);
            }
            catch (e) {
                return {
                    body: base64encode(`Error while unzipping the body: ${e.message}`),
                    bodyLength: body.length,
                    bodyTruncated: true,
                };
            }
        }
        return {
            body: body.slice(0, MAX_BODY_LENGTH).toString('base64'),
            bodyLength: body.length,
            bodyTruncated: body.length > MAX_BODY_LENGTH,
        };
    }
    catch (e) {
        // istanbul ignore next
        return {
            body: base64encode(`Error while getting body logging data: ${e && e.message}`),
            bodyLength: rawBody.length,
            bodyTruncated: true,
        };
    }
}
exports.default = getBodyLoggingData;
