"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const path_1 = require("path");
const BackendFetchError_1 = __importDefault(require("../errors/BackendFetchError"));
const mergeQueryString_1 = __importDefault(require("./mergeQueryString"));
const constants_1 = require("../constants");
/**
 * Array of response headers that will not be passed over directly from the proxied resource
 *
 * Notes:
 * - transfer-encoding: as it poisons the response which will be formed
 * based on its own transfer-encoding rather than the one received from the Lambda.
 *
 * - content-length: as the actual constant may be changed by buffer proxy
 * (e.g. on moov_debug=true)
 * @private
 */
const IGNORE_RESPONSE_HEADERS = ['transfer-encoding', 'content-length'];
/**
 * @private
 */
class Backend {
    constructor(config) {
        this.config = config;
    }
    /**
     * Sends a request using the proxy.
     * @param req The request being sent.
     * @param res The response for the request.
     */
    async fetch(req, res, options) {
        const { path, headers } = options || {};
        // Create url for proxy with query params added if existing
        const url = this.getProxyTarget(req, path);
        const requestOptions = this.getProxyRequestOptions(url, req, headers);
        return new Promise((resolve, reject) => {
            const lib = url.protocol === 'https:' ? https_1.default : http_1.default;
            const upstreamReq = lib.request(requestOptions, upstreamRes => {
                let buf = [];
                upstreamRes
                    .on('data', (chunk) => buf.push(chunk))
                    .on('end', () => {
                    Object.entries(upstreamRes.headers)
                        .filter(([name]) => !IGNORE_RESPONSE_HEADERS.includes(name.toLowerCase()))
                        .forEach(([name, value]) => {
                        try {
                            res.setHeader(name, value);
                        }
                        catch (e) {
                            console.warn(`Could not relay upstream response header ${name} with value ${value}`, e);
                        }
                    });
                    res.statusCode = upstreamRes.statusCode;
                    res.statusMessage = upstreamRes.statusMessage;
                    res.body = Buffer.concat(buf);
                    resolve(undefined);
                });
            });
            upstreamReq.on('error', e => reject(new BackendFetchError_1.default(e)));
            upstreamReq.end(req.body);
        });
    }
    /**
     * Returns proxy configuration for http-proxy
     * @returns proxy target url
     */
    getProxyTarget(req, path) {
        let url = path ? mergeQueryString_1.default(req.url, path) : req.url;
        const { domainOrIp, basePath, port } = this.config;
        if (basePath) {
            url = path_1.join(basePath, url);
        }
        /* istanbul ignore next */
        if (domainOrIp) {
            const protocol = domainOrIp.match(/^127.0.0.1(:\d+)?$/) ? 'http' : 'https';
            const domain = `${domainOrIp}${port ? `:${port}` : ''}`;
            url = `${protocol}://${path_1.join(domain, url)}`;
        }
        return url_1.parse(url, true);
    }
    /**
     * Returns true if the URL points to the local JS backend, otherwise false.
     * @param url
     * @returns
     */
    isLocal(url) {
        return url.hostname === constants_1.JS_BACKEND_HOSTNAME;
    }
    /**
     * Returns proxy configuration object for node-fetch
     * @param url
     * @param req
     * @param headers Additional request headers to include
     */
    getProxyRequestOptions(url, req, headers) {
        let agent = null;
        if (this.config.disableCheckCert && url.protocol === 'https:') {
            // For self signed cert fix on local development S3 bucket
            agent = new https_1.default.Agent({ rejectUnauthorized: false });
        }
        const upstreamHeaders = {
            ...req.headers,
            ...headers,
            host: this.config.hostHeader || req.headers.host,
        };
        if (this.isLocal(url)) {
            // Some libraries, like [is-https](https://github.com/unjs/is-https#behaviour), rely on x-forwarded-proto
            // to determine if the source request was made securely. This is notably used by Vue Storefront 2. Before
            // we added this header, API requests made by Vue Storefront 2 from the cloud would attempt to reenter Layer0
            // using an http POST, which would be redirected to an https GET, which would cause an infinite loop and soaring lambda costs.
            // Note that we only add x-forwarded-proto for local requests, which never happen over TLS. For remote requests, TLS is used
            // when the downstream request used TLS. We've chosen to do this in order to avoid altering the public behavior of Layer0, which
            // has never sent x-forwarded-proto to origins.
            upstreamHeaders['x-forwarded-proto'] = req.secure ? 'https' : 'http';
        }
        return {
            ...url,
            method: req.method,
            timeout: this.config.firstByteTimeout || 0,
            agent,
            body: req.body,
            headers: upstreamHeaders,
        };
    }
}
exports.default = Backend;
